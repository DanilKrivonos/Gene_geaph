import argparse
import numpy as np
import pandas as pd
from pyteomics.fasta import read
import sys
import os

parser = argparse.ArgumentParser()
parser.add_argument('-input', 
    type=str, 
    help='blocks_coors.txt file generated by Sibelia', 
    required=True
    )
parser.add_argument('-save_way', 
    type=str, 
    help='Output filename', 
    required=True
    )
parser.add_argument('-data_type', 
    type=str, 
    help='If fold or file', 
    default='file'
    )
parser.add_argument('-spike', 
    type=str, 
    help='Additional information. If you need print Need', 
    default='No'
    )
parser.add_argument('-refpa', 
    type=str, 
    help='Path of organisms fold', 
    default=None
    )
args = parser.parse_args()

if args.data_type == 'file':
    blocks_file = open(args.input, 'r')

    graph = {}
    sections = []
    section = []

    print('Read file ...')
    for line in blocks_file:
        if '--' in line:
            sections.append(section)
            section = []
            continue
        section.append(line[:-1].split('\t'))

    print('Processing ...')
    max_length = -1
    for section in sections:
        if 'Description' in section[0]:
            for line in section[1:]:

                graph[line[0]] = {
                    'blocks': [],
                    'size': line[1],
                    'description': line[2]
                }
            continue
        
        block_name = section[0][0].split(' ')[-1][1:]

        for line in section[2:]:
            seq_id, strand, start, end, length = line
            
            if int(length) > max_length:
                max_length = int(length)

            graph[seq_id]['blocks'].append( 
                [int(start), int(end), int(length), block_name, strand] 
            )

    out = open(args.save_way + '.txt', 'w')
    out.write('Strat_SB\tNext_SB\tStrain\tStart_coordinate\tEnd_coordinate\tLength_of_the largest_SB\n')
    if args.spike == 'Need':
        helper = open(args.save_way + '/_helper.txt', 'w')
    if args.refpa != None:
        p = pd.read_csv(args.input + str(args.input).split('/')[-1] + '/blocks_coords.txt',
            header=None, 
            names=('ind', 'size', 'describtion'), 
            sep='\t'
            )
        check_list = {}
        checker = []
        for i in range(len(p)):
            if str(p['describtion'][i]) != 'nan':
                if str(p['describtion'][i]) != 'Description':
                    check_list[str(p['describtion'][i])] = {}
                    checker.append(str(p['describtion'][i]))
            else:
                break
            
        strains = args.refpa
        
        for sta in strains:
            if '.DS_Store' in sta:
                continue
            op_pa = read(args.refpa + '/All/{}'.format(sta))
            for line in op_pa:
                for num in check_list:
                    if num in line.description:
                        check_list[num] = [sta[: -12]]
        last = []
        for ind in check_list:
                last.append(check_list[ind])

    print('Write graph ...')
    for seq_id in graph:
        graph[seq_id]['blocks'].sort()
        blocks = graph[seq_id]['blocks']
        for i in range(len(blocks) - 1):
            if args.refpa != None:
                out.write('sb{}\tsb{}\t{}\t{}\t{}\t{}\n'.format(
                    blocks[i][3],
                    blocks[i+1][3],
                    str(last[int(seq_id) - 1][0]),
                    blocks[i][0],
                    blocks[i][1],
                    max_length,
                    ))
            else:
                out.write('sb{}\tsb{}\tg{}\t{}\t{}\t{}\n'.format(
                    blocks[i][3],
                    blocks[i+1][3],
                    seq_id,
                    blocks[i][0],
                    blocks[i][1],
                    max_length,
                    ))
            if args.spike == 'Need':
                helper.write('{}\t{}\t{}\n'.format(
                    str(last[int(seq_id) - 1][0]),
                    checker[int(seq_id) - 1],
                    blocks[i][-1],
                    ))
    out.close() 
    if args.spike == 'Need':
        helper.close()
elif args.data_type == 'fold':
    paths = os.listdir(args.input)
    
    for org in paths:
        if '.DS_Store' in org:
            continue
        #Change your way
        if '_result' in org:
            blocks_file = open(args.input + '/{}/blocks_coords.txt'.format(org))

            graph = {}
            sections = []
            section = []

            print('Read file ...')
          
            for line in blocks_file:
                if '--' in line:
                    sections.append(section)
                    section = []
                    continue
                section.append(line[:-1].split('\t'))
            

            print('Processing ...')
            max_length = -1
            for section in sections:
                if 'Description' in section[0]:
                    for line in section[1:]:
                        graph[line[0]] = {
                            'blocks': [],
                            'size': line[1],
                            'description': line[2], 
                        }
                    continue
                block_name = section[0][0].split(' ')[-1][1:]

                for line in section[2:]:
                    seq_id, strand, start, end, length = line
                    
                    if int(length) > max_length:
                        max_length = int(length)

                    graph[seq_id]['blocks'].append( 
                        [int(start), int(end), int(length), block_name, strand] 
                    )
    
    
            out = open(args.save_way + org + '/{}.txt'.format(org[: -16]), 'w')
            out.write('Strat_SB\tNext_SB\tStrain\tStart_coordinate\tEnd_coordinate\tLength_of_the largest_SB\n')
            if args.spike == 'Need':
                helper = open(args.save_way + org + '/{}_helper.txt'.format(org[: -16]), 'w')
                helper.write('Strain\tContig\tBranch\n')
            if args.refpa != None:
                p = pd.read_csv(args.input + '/{}/blocks_coords.txt'.format(org),
                    header=None, 
                    names=('ind', 'size', 'describtion'), 
                    sep='\t'
                    )
            
                check_list = {}
                checker = []
                for i in range(len(p)):
                    if str(p['describtion'][i]) != 'nan':
                        if str(p['describtion'][i]) != 'Description':
                            check_list[str(p['describtion'][i])] = {}
                            checker.append(str(p['describtion'][i]))
                    else:
                        break
                    
                strains = os.listdir(args.refpa + org[: -16] + '/All/')
                
                for sta in strains:
                    if '.DS_Store' in sta:
                        continue
                    op_pa = read(args.refpa + org[: -16] + '/All/{}'.format(sta))
                    for line in op_pa:
                        for num in check_list:
                            if num in line.description:
                                check_list[num] = [sta[: -12]]
                last = []
                for ind in check_list:
                        last.append(check_list[ind])

            print('Analyzing of {} ...'.format(org[: -16]))
            for seq_id in graph:
                print('Analyzing of {} ...'.format(str(last[int(seq_id) - 1][0])))
                graph[seq_id]['blocks'].sort()
                blocks = graph[seq_id]['blocks']
                for i in range(len(blocks) - 1):
                    if args.refpa != None:
                        out.write('sb{}\tsb{}\t{}\t{}\t{}\t{}\n'.format(
                            blocks[i][3],
                            blocks[i+1][3],
                            str(last[int(seq_id) - 1][0]),
                            blocks[i][0],
                            blocks[i][1],
                            max_length,
                            ))
                    else:
                        out.write('sb{}\tsb{}\tg{}\t{}\t{}\t{}\n'.format(
                            blocks[i][3],
                            blocks[i+1][3],
                            seq_id,
                            blocks[i][0],
                            blocks[i][1],
                            max_length,
                            ))
                    if args.spike == 'Need':
                        helper.write('{}\t{}\t{}\n'.format(
                            str(last[int(seq_id) - 1][0]),
                            checker[int(seq_id) - 1],
                            blocks[i][-1],
                            ))
            out.close() 
            if args.spike == 'Need':
                helper.close()
            print('Analyzing of {} was done!'.format(org[: -16]))
else:
    print('Unsupportable format :(')

print('Done!')